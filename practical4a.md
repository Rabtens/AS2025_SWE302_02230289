# Practical 4a — SonarCloud SAST Integration with GitHub Actions

Overview
--------
This practical documents a complete integration of SonarCloud Static Application Security Testing (SAST) into a GitHub Actions CI pipeline for the `cicd_demo1` Spring Boot project. The goal is to automatically analyze source code for security weaknesses, bugs, code smells and test coverage regressions, and to enforce quality gates so that problematic code is identified early in the development lifecycle.

This write-up explains the motivation, design choices, configuration files, CI workflow, encountered problems and their resolutions, lessons learned, and recommended follow-ups. The content is intentionally detailed so it can be reproduced or adapted for other Java projects.

Table of contents
- What this practical is about
- Approach and planning
- Implementation details
	- sonar-project.properties
	- Maven (pom.xml) changes
	- GitHub Actions workflow
- Verification and evidence
- Problems encountered and solutions
- Lessons learned and recommendations
- Conclusion and next steps

What this practical is about
---------------------------
This practical focuses on adding source-code analysis (SAST) into the CI pipeline using SonarCloud. While dependency scanners (e.g., Snyk) detect known vulnerable libraries, SonarCloud inspects application code to surface:

- Security vulnerabilities and hotspots (patterns that need manual review)
- Bugs and potential defects
- Code smells and maintainability issues
- Test coverage metrics (via JaCoCo)
- Enforced quality gates to block or warn about problematic merges

Key objectives
- Integrate SonarCloud so the repository is scanned automatically on pushes and pull requests
- Ensure PRs receive in-context feedback (PR decoration)
- Generate coverage metrics and attach them to the analysis
- Use secrets for authentication and keep scanning non-blocking during initial setup

Approach and planning
---------------------
The integration was completed in clearly defined phases:

1. Account and repository setup — create SonarCloud account, organization and token; add required repo to SonarCloud.
2. Local project mapping — create `sonar-project.properties` with source/test paths and coverage locations.
3. Build tooling — add Sonar Maven plugin and JaCoCo plugin to `pom.xml` so CI produces artifacts SonarCloud can use.
4. CI automation — add a dedicated `sonarqube.yml` workflow in `.github/workflows/` that builds, tests and runs `mvn sonar:sonar`.
5. Validation & tuning — test with PR and push triggers; adjust coverage paths and secrets; enable PR decoration.

Implementation
--------------
The implementation has three main configuration pieces: Sonar config, Maven updates and the GitHub Actions workflow.

1) sonar-project.properties
---------------------------
Create a `sonar-project.properties` at the repository root so SonarCloud knows how to locate source files, tests and coverage reports. Example:

```properties
# sonar-project.properties
sonar.projectKey=Rynorbu_cicd_demo1
sonar.organization=rynorbu
sonar.projectName=CICD Demo
sonar.projectVersion=1.0

# Sources and tests
sonar.sources=src/main/java
sonar.tests=src/test/java

# Java settings
sonar.java.source=17
sonar.java.binaries=target/classes

# Coverage
sonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml

# Encoding and exclusions
sonar.sourceEncoding=UTF-8
sonar.exclusions=**/*Test.java,**/test/**
```

Notes:
- `sonar.projectKey` must match the project created in SonarCloud and is often of the form `<org>_<repo>`.
- `sonar.coverage.jacoco.xmlReportPaths` points to the JaCoCo XML report generated by Maven (the path must match your `pom.xml` configuration).

2) Maven changes (pom.xml)
--------------------------
Add the Sonar Maven plugin and JaCoCo plugin to ensure the CI build produces coverage and can invoke the scanner. Minimal example snippets:

```xml
<properties>
	<java.version>17</java.version>
	<sonar.host.url>https://sonarcloud.io</sonar.host.url>
</properties>

<build>
	<plugins>
		<!-- Sonar Maven Plugin -->
		<plugin>
			<groupId>org.sonarsource.scanner.maven</groupId>
			<artifactId>sonar-maven-plugin</artifactId>
			<version>3.10.0.2594</version>
		</plugin>

		<!-- JaCoCo coverage -->
		<plugin>
			<groupId>org.jacoco</groupId>
			<artifactId>jacoco-maven-plugin</artifactId>
			<version>0.8.11</version>
			<executions>
				<execution>
					<id>prepare-agent</id>
					<goals>
						<goal>prepare-agent</goal>
					</goals>
				</execution>
				<execution>
					<id>report</id>
					<phase>test</phase>
					<goals>
						<goal>report</goal>
					</goals>
				</execution>
			</executions>
		</plugin>
	</plugins>
</build>
```

Practical tips:
- Ensure tests are executed (`mvn verify` or `mvn test`) in CI before running Sonar so JaCoCo produces the XML report.
- The JaCoCo `report` execution produces the `target/site/jacoco/jacoco.xml` file that Sonar expects.

3) GitHub Actions workflow
-------------------------
Create `.github/workflows/sonarqube.yml` to automate scanning. The workflow below is designed to be robust and includes debug and validation steps to simplify troubleshooting:

```yaml
name: SonarCloud SAST

on:
	push:
		branches: [ main, master ]
	pull_request:
		types: [opened, synchronize, reopened]

jobs:
	sonarcloud:
		runs-on: ubuntu-latest
		continue-on-error: false

		steps:
			- name: Checkout
				uses: actions/checkout@v4
				with:
					fetch-depth: 0

			- name: Set up JDK 17
				uses: actions/setup-java@v4
				with:
					java-version: '17'
					distribution: 'temurin'
					cache: maven

			- name: Build and run tests (with coverage)
				run: mvn clean verify -DskipITs=false

			- name: Debug - verify environment
				run: |
					echo "Maven version:"; mvn -v
					echo "Project root listing:"; ls -la
					echo "sonar-project.properties:"; cat sonar-project.properties || true

			- name: Check SONAR_TOKEN
				run: |
					if [ -z "${{ secrets.SONAR_TOKEN }}" ]; then
						echo "SONAR_TOKEN is not set"; exit 1
					fi

			- name: Run SonarCloud analysis
				env:
					GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
					SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
				run: |
					mvn sonar:sonar \
						-Dsonar.projectKey=Rynorbu_cicd_demo1 \
						-Dsonar.organization=rynorbu \
						-Dsonar.host.url=https://sonarcloud.io \
						-Dsonar.login=${{ secrets.SONAR_TOKEN }}
```

Notes about the workflow:
- `fetch-depth: 0` gives Sonar full Git history to compute new code metrics accurately.
- `continue-on-error` is set to `false` here to enforce quality gates. During initial setup you may want it set to `true` while tuning rules.
- `GITHUB_TOKEN` (automatic) is used by Sonar to post PR decorations; `SONAR_TOKEN` must be added as a repository secret.

Verification and evidence
-------------------------
To validate the integration, check these items:

- GitHub Actions: the `sonarcloud` job should complete and show the `Run SonarCloud analysis` step ran without error.
- SonarCloud Dashboard: the project must appear in your SonarCloud organization and show analysis results (issues, coverage, smells).
- PR Decoration: when a PR is opened or updated, SonarCloud should annotate it with analysis results (if `GITHUB_TOKEN` + `SONAR_TOKEN` are configured correctly).
- Coverage: JaCoCo coverage percentage must show in Sonar analysis — confirm `target/site/jacoco/jacoco.xml` exists after the build.

Recommended validation steps
1. Add an intentional code smell or simple security anti-pattern and open a PR to see PR decoration.
2. Temporarily add a failing quality gate rule (e.g., require 80% coverage) to see the pipeline fail when the gate is not met.
3. Use SonarCloud's UI to review issues, hotspots and suggested fixes.

Problems encountered and how they were fixed
-------------------------------------------
Below are real issues that commonly occur and the corrective actions applied:

1) Missing or incorrect secret
- Symptom: "Invalid token" or authentication errors from SonarCloud
- Fix: Ensure `SONAR_TOKEN` secret exists in repository Settings → Secrets and variables → Actions, and match the name used in the workflow.

2) Incorrect project key or organization
- Symptom: Sonar reports `Project not found`.
- Fix: Use the exact `projectKey` shown in SonarCloud (often `<org>_<repo>`). Keep values consistent across `sonar-project.properties` and the `mvn sonar:sonar` call.

3) Coverage not appearing
- Symptom: Sonar shows no coverage data.
- Fix: Ensure JaCoCo plugin is set up correctly and that CI runs tests prior to Sonar analysis. Confirm the JaCoCo XML path in `sonar-project.properties` matches the path generated by Maven.

4) Long scan times or CI resource usage
- Symptom: Sonar analysis adds significant time to CI runs.
- Fix: Use a separate, dedicated Sonar workflow to run in parallel to build/test jobs. Consider incremental analysis for branches or run full scans on schedule.

5) Build passes but quality gate fails
- Symptom: Developers confused why their PR shows green build but fails quality gate.
- Fix: Educate the team on difference between build result and quality gate; use PR decoration and clear documentation to show gate expectations. Initially allow failures (continue-on-error) while team adapts.

Lessons learned and recommendations
---------------------------------

- Use separate workflows: Keep SonarCloud scanning in a dedicated workflow for modularity and easier troubleshooting.
- Start non-blocking: During rollout, set `continue-on-error: true` or don't block merges until rules are tuned; then tighten gates progressively.
- Enforce new code standards: Configure quality gates so new code must meet stricter criteria while legacy code has an improvement plan.
- Combine tools: SonarCloud (SAST) + Snyk (dependency CVEs) + ZAP (DAST) gives layered security.
- Developer feedback: Install SonarLint for IDEs so developers catch issues locally before PRs.
- Automation: Use scheduled scans for long-lived branches and full scans; run PR-scans for fast feedback.
- Documentation: Add `SECURITY.md` or `sonar/README.md` describing how to interpret Sonar issues, how to assign triage owners, and how to fix common hotspots.

Extra best practices
- Configure project-level settings in SonarCloud: custom quality gate thresholds, rulesets and issue severities matched to your organization policy.
- Set up automatic alerting (Slack, e-mail) for critical findings using SonarCloud integrations.
- Use Sonar's API or badges to add quality metrics to your README for visibility.

Conclusion and next steps
-------------------------
This integration delivers automated source-code security scanning and quality checks as part of CI. The benefits are immediate feedback for developers, enforceable gates for quality, and dashboards for long-term monitoring.

Next recommended steps:
1. Add `sonarqube.yml` into the repo (if not already present) and enable PR decoration.
2. Create `SECURITY.md` that maps common Sonar issues to remediation steps and owners.
3. Combine SonarCloud with Snyk and container scanning in a single security matrix workflow for broader coverage.
4. Roll out SonarLint to the team and schedule a training session on interpreting Sonar results.

Evidence and artifacts
----------------------
Include screenshots of the SonarCloud dashboard, PR decoration, and the GitHub Actions job logs. Example filenames (place in an `assets/` folder):

![alt text](<Practicals/practical4a/assets/Screenshot from 2025-11-30 12-37-58.png>)

![alt text](<Practicals/practical4a/assets/Screenshot from 2025-11-30 12-38-19.png>)

![alt text](<Practicals/practical4a/assets/Screenshot from 2025-11-30 12-38-43.png>)
